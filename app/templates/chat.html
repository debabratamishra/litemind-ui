{% extends "base.html" %}
{% block content %}
<div class="max-w-3xl mx-auto mt-8 mb-8 flex flex-col flex-grow">
    <h2 class="text-3xl font-bold mb-6 text-center text-indigo-300">Chat with LLM</h2>

    <div id="chat-container" class="flex-grow h-[calc(100vh-16rem)] overflow-y-auto"></div>

    <!-- typing dots -->
    <div id="typing-indicator" class="typing">
        <span></span><span></span><span></span>
    </div>

    <!-- prompt input -->
    <div class="mt-4 flex space-x-2">
        <input type="text" id="prompt"
               class="flex-1 p-3 rounded-lg bg-gray-800 border border-gray-700
                      focus:outline-none focus:ring-2 focus:ring-indigo-500 transition
                      placeholder-gray-400"
               placeholder="Type your messageâ€¦">
        <button id="send-btn"
                class="bg-indigo-600 hover:bg-indigo-700 p-3 rounded-lg font-semibold transition">
            Send
        </button>
    </div>
</div>

<script>
const chatContainer   = document.getElementById('chat-container');
const typingIndicator = document.getElementById('typing-indicator');
const sendBtn         = document.getElementById('send-btn');
const promptInput     = document.getElementById('prompt');

/** Scroll helper */
const scrollToBottom = () => {
  chatContainer.scrollTop = chatContainer.scrollHeight;
};

sendBtn.addEventListener('click', async () => {
  const prompt = promptInput.value.trim();
  if (!prompt) return;

  /* -- user bubble -- */
  const userBubble       = document.createElement('div');
  userBubble.className   = 'message-bubble user animate-fade-in';
  userBubble.textContent = `You: ${prompt}`;
  chatContainer.appendChild(userBubble);
  scrollToBottom();

  typingIndicator.style.display = 'flex';

  try {
    const res = await fetch('/chat/api/chat', {
      method : 'POST',
      headers: { 'Content-Type': 'application/json' },
      body   : JSON.stringify({ prompt })
    });

    if (!res.ok) throw new Error(await res.text());

    const reader   = res.body.getReader();
    const decoder  = new TextDecoder();
    let   mdBuffer = '';

    /* -- assistant bubble (single, keeps updating) -- */
    const botBubble    = document.createElement('div');
    botBubble.className= 'message-bubble llm';
    const streamDiv    = document.createElement('div');
    botBubble.appendChild(streamDiv);
    chatContainer.appendChild(botBubble);

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      mdBuffer += decoder.decode(value);

      /* render full Markdown every tick */
      streamDiv.innerHTML = marked.parse(mdBuffer);
      hljs.highlightAll();
      scrollToBottom();
    }
  } catch (err) {
    const errBubble = document.createElement('div');
    errBubble.className = 'message-bubble llm text-red-500 animate-fade-in';
    errBubble.textContent = `Error: ${err.message || 'Network error'}`;
    chatContainer.appendChild(errBubble);
  } finally {
    typingIndicator.style.display = 'none';
    promptInput.value = '';
    scrollToBottom();
  }
});
</script>
{% endblock %}
